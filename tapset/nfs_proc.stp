// NFS procedure tapset
// Copyright (C) 2006 IBM Corp.
// Copyright (C) 2007-2012 Red Hat
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

%{
/* For AF_INET */
#include <linux/socket.h>
%}

function AF_INET:long()
{
	return %{ /* pure */ /* unprivileged */ AF_INET %}
}

function AF_INET6:long()
{
	return %{ /* pure */ /* unprivileged */ AF_INET6 %}
}

function NFS_I:long(inode:long)
{
	/*
	 * Notice we're casting 0 here on purpose.  We need the offset
	 * of the 'vfs_inode' member of 'struct nfs_inode'.  This is
	 * the script language equivalent of:
	 *    offset = offsetof(struct nfs_inode, vfs_inode);
	 */
	offset = &@cast(0, "nfs_inode", "kernel:nfs")->vfs_inode

	return (inode - offset)
}

function NFS_FH:long(inode:long)
{
	return &@cast(NFS_I(inode), "nfs_inode", "kernel:nfs")->fh
}

function NFS_SERVER:long(inode:long)
{
	return @cast(inode, "inode")->i_sb->s_fs_info
}

function NFS_CLIENT:long(inode:long)
{
	return @cast(NFS_SERVER(inode), "nfs_server", "kernel:nfs")->client
}

/* deprecated */
function stap_NFS_CLIENT:long(inode:long)
{
	return NFS_CLIENT(inode)
}

function NFS_PROTO:long(inode:long)
{
    nfsserver = NFS_SERVER(inode)
    return (@defined(@cast(nfsserver, "nfs_server", "kernel:nfs")->nfs_client)
	    ? @cast(nfsserver, "nfs_server", "kernel:nfs")->nfs_client->rpc_ops
	    : @cast(nfsserver, "nfs_server", "kernel:nfs")->rpc_ops)
}


/* Get ip address from a rpc_clnt */
function get_ip_from_client:long(clnt:long)
{
	cl_xprt = @cast(clnt, "rpc_clnt", "kernel:sunrpc")->cl_xprt
	addr = &@cast(cl_xprt, "rpc_xprt", "kernel:sunrpc")->addr

	/* In reality, 'cl_xprt->addr' is of 'sockaddr_storage' type
	 * (since 2.6.19). But when used, you cast it to what is
	 * inside that buffer. */
	if (@cast(addr, "sockaddr_in")->sin_family
		!= %{ /* pure */ /* unprivileged */ AF_INET %}) {
		/* Now consider ipv4 only */
		return 0
	}
	return @cast(addr, "sockaddr_in")->sin_addr->s_addr
}

/* Get protocol types from a rpc_clnt */
function get_prot_from_client:long(clnt:long)
{
	cl_xprt = @cast(clnt, "rpc_clnt", "kernel:sunrpc")->cl_xprt
	return @cast(cl_xprt, "rpc_xprt", "kernel:sunrpc")->prot
}

/* Get ip address from a rpc_task */
function get_ip:long(task:long)
{
	clnt = @cast(task, "rpc_task", "kernel:sunrpc")->tk_client
	return get_ip_from_client(clnt)
}

/* Get protocol types from a rpc_task */
function get_prot:long(task:long)
{
	clnt = @cast(task, "rpc_task", "kernel:sunrpc")->tk_client
	return get_prot_from_client(clnt)
}

/*
  0:get ip address
  1:get proto
*/
function __i2n_ip_proto:long(dir:long, index:long)
{
	clnt = NFS_CLIENT(dir)

        if (index == 0)
		return get_ip_from_client(clnt)
	if (index == 1)
		return get_prot_from_client(clnt)
	return 0
}

/*
  0: get ip address
  1: get proto
  2: get res->count
  3: get res->fattr->valid
  4: get timestamp
*/
function __nfs_read_data_info:long (rdata :long,index :long)
{
	task = &@cast(rdata, "nfs_read_data", "kernel:nfs")->task
	rres = &@cast(rdata, "nfs_read_data", "kernel:nfs")->res

	if (index == 0)
		return get_ip(task)
	if (index == 1)
		return get_prot(task)
	if (index == 2)
		return @cast(rres, "nfs_readres", "kernel:nfs")->count
	if (index == 3)
		return @cast(rres, "nfs_readres", "kernel:nfs")->fattr->valid
%( CONFIG_NFS_V4 == "[ym]" %?
	if (index == 4)
		return @cast(rdata, "nfs_read_data", "kernel:nfs")->timestamp
%)
	return 0
}

/*
  0: get ip address
  1: get proto
  2: get res->count
  3: get res->fattr->valid
  4: get timestamp
*/
function __nfs_write_data_info:long (wdata :long,index :long)
{
	task = &@cast(wdata, "nfs_write_data", "kernel:nfs")->task
	wres = &@cast(wdata, "nfs_write_data", "kernel:nfs")->res

	if (index == 0)
		return get_ip(task)
	if (index == 1)
		return get_prot(task)
	if (index == 2)
		return @cast(wres, "nfs_writeres", "kernel:nfs")->count
	if (index == 3)
		return @cast(wres, "nfs_writeres", "kernel:nfs")->fattr->valid
%( CONFIG_NFS_V4 == "[ym]" %?
	if (index == 4)
		return @cast(wdata, "nfs_write_data", "kernel:nfs")->timestamp
%)
	return 0
}

function __nfsv4_bitmask:long(dir:long, i:long)
{
%( CONFIG_NFS_V4 == "[ym]" %?
	return @cast(NFS_SERVER(dir), "nfs_server", "kernel:nfs")->attr_bitmask[i]
%)
	return 0
}

/* deprecated */
function __getfh_inode:long(dir:long)
{
	return NFS_FH(dir)
}

probe nfs.proc.entries = nfs.proc.lookup,
			nfs.proc.read ?,
			nfs.proc.write ?,
			nfs.proc.commit ?,
			nfs.proc.read_setup,
			nfs.proc.write_setup,
			nfs.proc.commit_setup,
			nfs.proc.read_done,
			nfs.proc.write_done,
			nfs.proc.commit_done,
			nfs.proc.open,
			nfs.proc.create,
			nfs.proc.rename,
			nfs.proc.remove,
			nfs.proc.release
{
}


probe nfs.proc.return = nfs.proc.lookup.return,
			nfs.proc.read.return ?,
			nfs.proc.write.return ?,
			nfs.proc.commit.return ?,
			nfs.proc.read_setup.return,
			nfs.proc.write_setup.return,
			nfs.proc.commit_setup.return,
			nfs.proc.read_done.return,
			nfs.proc.write_done.return,
			nfs.proc.commit_done.return,
			nfs.proc.open.return,
			nfs.proc.create.return,
			nfs.proc.rename.return,
			nfs.proc.remove.return,
			nfs.proc.release.return  
{
}

/**
 * probe nfs.proc.lookup - NFS client opens/searches a file on server
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version
 * @filename: the name of  file which client opens/searches on server
 * @name_len: the length of file name
 * @bitmask0: V4 bitmask representing the set
 *            of attributes supported on this filesystem
 * @bitmask1: V4 bitmask representing the set
 *            of attributes supported on this filesystem
 */
probe nfs.proc.lookup = nfs.proc2.lookup,
                        nfs.proc3.lookup,
                        nfs.proc4.lookup
{
}

probe nfs.proc.lookup.return = nfs.proc2.lookup.return,
                               nfs.proc3.lookup.return,
                               nfs.proc4.lookup.return
{}

probe nfs.proc2.lookup = kernel.function("nfs_proc_lookup")!,
                         module("nfs").function("nfs_proc_lookup")?
{
	server_ip = __i2n_ip_proto($dir,0)
        prot   = __i2n_ip_proto($dir,1)
        version =2

	name_len = $name->len
	filename = kernel_string_n($name->name, name_len)
        bitmask0 = 0
        bitmask1 = 0

        name = "nfs.proc2.lookup"
        argstr = sprintf("%s",filename) 
}

probe nfs.proc2.lookup.return = kernel.function("nfs_proc_lookup").return!,
                                module("nfs").function("nfs_proc_lookup").return?
{
        version =2
	name = "nfs.proc2.lookup.return"
	retstr = sprintf("%d", $return)
}

probe nfs.proc3.lookup = kernel.function("nfs3_proc_lookup")!,
                         module("nfs").function("nfs3_proc_lookup")?
{

	server_ip = __i2n_ip_proto($dir,0)
        prot   = __i2n_ip_proto($dir,1)
        version =3

	name_len = $name->len
	filename = kernel_string_n($name->name, name_len)
        bitmask0 = 0
        bitmask1 = 0

        name = "nfs.proc3.lookup"
        argstr = sprintf("%s",filename) 
}


probe nfs.proc3.lookup.return = kernel.function("nfs3_proc_lookup").return!,
                                module("nfs").function("nfs3_proc_lookup").return?
{
        version =3
	name = "nfs.proc3.lookup.return"
	retstr = sprintf("%d", $return)
}

probe nfs.proc4.lookup = kernel.function("nfs4_proc_lookup")!,
                         module("nfs").function("nfs4_proc_lookup")?
{

	server_ip = __i2n_ip_proto($dir,0)
        prot   = __i2n_ip_proto($dir,1)
        version =4

	name_len = $name->len
	filename = kernel_string_n($name->name, name_len)
        bitmask0 = __nfsv4_bitmask($dir,0)
        bitmask1 = __nfsv4_bitmask($dir,1)

        name = "nfs.proc4.lookup"
        argstr = sprintf("%s",filename) 
}

probe nfs.proc4.lookup.return = kernel.function("nfs4_proc_lookup").return!,
                                module("nfs").function("nfs4_proc_lookup").return?
{
        version =4
	name = "nfs.proc4.lookup.return"
	retstr = sprintf("%d", $return)
}

/**
 * probe nfs.proc.read - NFS client synchronously reads file from server
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version
 * @flags: used to set task->tk_flags in rpc_init_task function
 * @size:
 * @count: read bytes in this execution
 * @offset: the file offset
 * 
 * All the nfs.proc.read kernel functions were removed in kernel commit
 * 8e0969 in December 2006, so these probes do not exist on Linux
 * 2.6.21 and newer kernels.
 */
probe nfs.proc.read = nfs.proc2.read ?,
                      nfs.proc3.read ?,
                      nfs.proc4.read ?
{}


probe nfs.proc.read.return = nfs.proc2.read.return ?,
                      nfs.proc3.read.return ?,
                      nfs.proc4.read.return ?
{
}

probe nfs.proc2.read = kernel.function("nfs_proc_read") !,
                       module("nfs").function("nfs_proc_read")?
{
	server_ip = __nfs_read_data_info($rdata,0)
        prot = __nfs_read_data_info($rdata,1)
        version =2

	flags = $rdata->flags
        count = $rdata->args->count
        offset = $rdata->args->offset

	name = "nfs.proc2.read"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

probe nfs.proc2.read.return = kernel.function("nfs_proc_read").return !,
                       module("nfs").function("nfs_proc_read").return?
{
        version =2
	name = "nfs.proc2.read.return"
	retstr = sprintf("%d", $return)
}


probe nfs.proc3.read = kernel.function("nfs3_proc_read") !,
                       module("nfs").function("nfs3_proc_read")?
{
	server_ip = __nfs_read_data_info($rdata,0)
        prot = __nfs_read_data_info($rdata,1)
        version =3

	flags = $rdata->flags
        count = $rdata->args->count
        offset = $rdata->args->offset

	name = "nfs.proc3.read"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

probe nfs.proc3.read.return = kernel.function("nfs3_proc_read").return !,
                       module("nfs").function("nfs3_proc_read").return?
{
        version =3
	name = "nfs.proc3.read.return"
        retstr = sprintf("%d", $return)
}

probe nfs.proc4.read = kernel.function("nfs4_proc_read") !,
                       module("nfs").function("nfs4_proc_read")?
{
	server_ip = __nfs_read_data_info($rdata,0)
        prot = __nfs_read_data_info($rdata,1)
        version =4

	flags = $rdata->flags
        count = $rdata->args->count
        offset = $rdata->args->offset

	name = "nfs.proc4.read"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

probe nfs.proc4.read.return = kernel.function("nfs4_proc_read").return !,
                       module("nfs").function("nfs4_proc_read").return?
{
        version =4
	name = "nfs.proc4.read.return"
        retstr = sprintf("%d", $return)
}


/**
 * probe nfs.proc.write - NFS client synchronously writes file to server
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version
 * @flags: used to set task->tk_flags in rpc_init_task function
 * @count:
 * @size: read bytes in this execution
 * @offset: the file offset
 * @bitmask0: V4 bitmask representing the set
 *            of attributes supported on this filesystem
 * @bitmask1: V4 bitmask representing the set
 *            of attributes supported on this filesystem
 *
 * All the nfs.proc.write kernel functions were removed in kernel commit
 * 200baa in December 2006, so these probes do not exist on Linux
 * 2.6.21 and newer kernels.
 */

probe nfs.proc.write = nfs.proc2.write ?,
                      nfs.proc3.write ?,
                      nfs.proc4.write ?
{}


probe nfs.proc.write.return = nfs.proc2.write.return ?,
                      nfs.proc3.write.return ?,
                      nfs.proc4.write.return ?
{}

probe nfs.proc2.write = kernel.function("nfs_proc_write")!,
                        module("nfs").function("nfs_proc_write")?
{
	server_ip = __nfs_write_data_info($wdata,0)
        prot = __nfs_write_data_info($wdata,1)
        version =2

	flags = $wdata->flags
        count = $wdata->args->count
        offset = $wdata->args->offset
        bitmask0 = 0
        bitmask1 = 0

	name = "nfs.proc2.write"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

probe nfs.proc2.write.return = kernel.function("nfs_proc_write").return !,
                       module("nfs").function("nfs_proc_write").return?
{
        version =2
	name = "nfs.proc2.write.return"
	retstr = sprintf("%d", $return)
        if($return >= 0)
        {  
        	size = $return
	        units = "bytes"
	}
}


probe nfs.proc3.write = kernel.function("nfs3_proc_write")!,
                        module("nfs").function("nfs3_proc_write")?
{
      
	server_ip = __nfs_write_data_info($wdata,0)
        prot = __nfs_write_data_info($wdata,1)
        version =3

	flags = $wdata->flags
        count = $wdata->args->count
        offset = $wdata->args->offset
        bitmask0 = 0
        bitmask1 = 0

	name = "nfs.proc3.write"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}


probe nfs.proc3.write.return = kernel.function("nfs3_proc_write").return !,
                       module("nfs").function("nfs3_proc_write").return?
{
        version =3
	name = "nfs.proc3.write.return"
	retstr = sprintf("%d", $return)
        
        if($return >= 0)
        {  
        	size = $return
	        units = "bytes"
	}
}


probe nfs.proc4.write = kernel.function("nfs4_proc_write")!,
                        module("nfs").function("nfs4_proc_write")?
{
      
	server_ip = __nfs_write_data_info($wdata,0)
        prot = __nfs_write_data_info($wdata,1)
        version =4

	flags = $wdata->flags
        count = $wdata->args->count
        offset = $wdata->args->offset
        bitmask0 = __nfsv4_bitmask($wdata->inode,0)
        bitmask1 = __nfsv4_bitmask($wdata->inode,1)

	name = "nfs.proc4.write"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}


probe nfs.proc4.write.return = kernel.function("nfs4_proc_write").return !,
                       module("nfs").function("nfs4_proc_write").return?
{
        version =4
	name = "nfs.proc4.write.return"
	retstr = sprintf("%d", $return)
        
        if($return >= 0)
        {  
        	size = $return
	        units = "bytes"
	}
}

/**
 * probe nfs.proc.commit - NFS client committing data on server
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version
 * @count:
 * @size: read bytes in this execution
 * @offset: the file offset
 * @bitmask0: V4 bitmask representing the set
 *            of attributes supported on this filesystem
 * @bitmask1 :V4 bitmask representing the set
 *            of attributes supported on this filesystem
 *
 * All the nfs.proc.commit kernel functions were removed in kernel
 * commit 200baa in December 2006, so these probes do not exist on Linux
 * 2.6.21 and newer kernels.
 *
 * Fires when client writes the buffered data to disk.
 * The buffered data is asynchronously written by client earlier.
 * The commit function works in sync way.
 * This probe point does not exist in NFSv2.
 */
probe nfs.proc.commit = nfs.proc3.commit ?,
                        nfs.proc4.commit ?
{}

probe nfs.proc.commit.return = nfs.proc3.commit.return ?,
                               nfs.proc4.commit.return ?
{}

// XXX: on kernels > 2.6.18 (?), module("nfs") -> module("nfsd") and
// function("nfsN...") becomes function("nfsdN...").  PR3833.
   
probe nfs.proc3.commit = kernel.function ("nfs3_proc_commit")!,
                         module("nfs").function("nfs3_proc_commit")?
{
	server_ip = __nfs_write_data_info($cdata,0)
        prot = __nfs_write_data_info($cdata,1)
        version =3

        count = $cdata->args->count
        offset = $cdata->args->offset
        bitmask0 = 0
        bitmask1 = 0

	name = "nfs.proc3.commit"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

probe nfs.proc3.commit.return = kernel.function ("nfs3_proc_commit").return!,
                         module("nfs").function("nfs3_proc_commit").return?
{
        version =3
	name = "nfs.proc3.commit.return"
	retstr = sprintf("%d", $return)
        
        if($return >= 0)
        {  
        	size = $return
	        units = "bytes"
	}
}


probe nfs.proc4.commit = kernel.function ("nfs4_proc_commit")!,
                         module("nfs").function("nfs4_proc_commit")?
{
	server_ip = __nfs_write_data_info($cdata,0)
        prot = __nfs_write_data_info($cdata,1)
        version =4

        count = $cdata->args->count
        offset = $cdata->args->offset
        bitmask0 = __nfsv4_bitmask($cdata->inode,0)
        bitmask1 = __nfsv4_bitmask($cdata->inode,1)

	name = "nfs.proc4.commit"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

probe nfs.proc4.commit.return = kernel.function ("nfs4_proc_commit").return!,
                         module("nfs").function("nfs4_proc_commit").return?
{
        version =4
	name = "nfs.proc4.commit.return"
	retstr = sprintf("%d", $return)
        
        if($return >= 0)
        {  
        	size = $return
	        units = "bytes"
	}
}

/**
 * probe nfs.proc.read_setup - NFS client setting up a read RPC task
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version
 * @count: read bytes in this execution
 * @size: read bytes in this execution
 * @offset: the file offset 
 *
 * The read_setup function is used to setup a read RPC task.
 * It is not doing the actual read operation.
 */
probe nfs.proc.read_setup = nfs.proc2.read_setup ,
                      nfs.proc3.read_setup ,
                      nfs.proc4.read_setup 
{}

probe nfs.proc.read_setup.return = nfs.proc2.read_setup.return ,
                      nfs.proc3.read_setup.return ,
                      nfs.proc4.read_setup.return 
{}



probe nfs.proc2.read_setup = kernel.function("nfs_proc_read_setup") !,
                       module("nfs").function("nfs_proc_read_setup")?
{
	client = NFS_CLIENT($data->inode)
	server_ip = get_ip_from_client(client)
	prot = get_prot_from_client(client)
        version =2

        count = $data->args->count
        offset = $data->args->offset

	name = "nfs.proc2.read_setup"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

probe nfs.proc2.read_setup.return = kernel.function("nfs_proc_read_setup").return !,
                       module("nfs").function("nfs_proc_read_setup").return?
{
        version =2
	name =  "nfs.proc2.read_setup.return"
	retvalue = 0;
}

probe nfs.proc3.read_setup = kernel.function("nfs3_proc_read_setup") !,
                       module("nfs").function("nfs3_proc_read_setup")?
{
	client = NFS_CLIENT($data->inode)
	server_ip = get_ip_from_client(client)
	prot = get_prot_from_client(client)
        version =3
	fh = 

        count = $data->args->count
        offset = $data->args->offset

	name = "nfs.proc3.read_setup"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

probe nfs.proc3.read_setup.return = kernel.function("nfs3_proc_read_setup").return !,
                       module("nfs").function("nfs3_proc_read_setup").return?
{
        version =3
	name =  "nfs.proc3.read_setup.return"
	retvalue = 0;
}

probe nfs.proc4.read_setup = kernel.function("nfs4_proc_read_setup") !,
                       module("nfs").function("nfs4_proc_read_setup")?
{
	client = NFS_CLIENT($data->inode)
	server_ip = get_ip_from_client(client)
	prot = get_prot_from_client(client)
        version =4

        count = $data->args->count
        offset = $data->args->offset
	//timestamp = $jiffies

	name = "nfs.proc4.read_setup"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}
probe nfs.proc4.read_setup.return = kernel.function("nfs4_proc_read_setup").return !,
                       module("nfs").function("nfs4_proc_read_setup").return?
{
        version =4
	name =  "nfs.proc4.read_setup.return"
	retvalue = 0;
}

/**
 * probe nfs.proc.read_done - NFS client response to a read RPC task
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version
 * @status: result of last operation
 * @count: number of bytes read
 * @timestamp : V4 timestamp, which is used for lease renewal
 *
 * Fires when a reply to a read RPC task is received or some read error occurs
 * (timeout or socket shutdown).
 */
probe nfs.proc.read_done = nfs.proc2.read_done,
                           nfs.proc3.read_done,
                           nfs.proc4.read_done
{}

probe nfs.proc.read_done.return = nfs.proc2.read_done.return,
                           nfs.proc3.read_done.return,
                           nfs.proc4.read_done.return
{}

probe nfs.proc2.read_done = kernel.function("nfs_read_done")!,
                            module("nfs").function("nfs_read_done")?
{
	if (@defined($data)) {		# kernels >= 2.6.10
		server_ip = __nfs_read_data_info($data,0)
	        prot = __nfs_read_data_info($data,1)
		count = __nfs_read_data_info($data, 2)
	}
	else {
		server_ip = __nfs_read_data_info($task->tk_calldata,0)
	        prot = __nfs_read_data_info($task->tk_calldata,1)
		count = __nfs_read_data_info($task->tk_calldata, 2)
	}
	timestamp = 0
        version =2
	status = $task->tk_status

	name = "nfs.proc2.read_done"
        argstr = sprintf("%d",status)

}

probe nfs.proc2.read_done.return = kernel.function("nfs_read_done").return!,
                            module("nfs").function("nfs_read_done").return?
{
        version =2
	name = "nfs.proc2.read_done.return"
	retstr = (@defined($return) ? sprintf("%d", $return) : "N/A")
}


probe nfs.proc3.read_done = kernel.function("nfs3_read_done")!,
                            module("nfs").function("nfs3_read_done")?
{
	if (@defined($data)) {		# kernels >= 2.6.10
		server_ip = __nfs_read_data_info($data,0)
	        prot = __nfs_read_data_info($data,1)
		count = __nfs_read_data_info($data, 2)
	}
	else {
		server_ip = __nfs_read_data_info($task->tk_calldata,0)
	        prot = __nfs_read_data_info($task->tk_calldata,1)
		count = __nfs_read_data_info($task->tk_calldata, 2)
	}
	timestamp = 0
        version =3
	status = $task->tk_status

	name = "nfs.proc3.read_done"
        argstr = sprintf("%d",status)

}

probe nfs.proc3.read_done.return = kernel.function("nfs3_read_done").return!,
                            module("nfs").function("nfs3_read_done").return?
{
        version =3
	name = "nfs.proc3.read_done.return"
	retstr = (@defined($return) ? sprintf("%d", $return) : "N/A")
}


probe nfs.proc4.read_done = kernel.function("nfs4_read_done")!,
                            module("nfs").function("nfs4_read_done")?
{
	if (@defined($data)) {		# kernels >= 2.6.10
		server_ip = __nfs_read_data_info($data,0)
	        prot = __nfs_read_data_info($data,1)
		count = __nfs_read_data_info($data, 2)
	        timestamp = __nfs_read_data_info($data, 4)
	}
	else {
		server_ip = __nfs_read_data_info($task->tk_calldata,0)
	        prot = __nfs_read_data_info($task->tk_calldata,1)
		count = __nfs_read_data_info($task->tk_calldata, 2)
	        timestamp = __nfs_read_data_info($task->tk_calldata, 4)
	}
        version =4
	status = $task->tk_status

	name = "nfs.proc4.read_done"
        argstr = sprintf("%d",status)

}

probe nfs.proc4.read_done.return = kernel.function("nfs4_read_done").return!,
                            module("nfs").function("nfs4_read_done").return?
{
        version =4
	name = "nfs.proc4.read_done.return"
	retstr = (@defined($return) ? sprintf("%d", $return) : "N/A")
}

/**
 * probe nfs.proc.write_setup - NFS client setting up a write RPC task
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version
 * @size: bytes written in this execution
 * @count: bytes written in this execution
 * @offset: the file offset
 * @how: used to set args.stable. The stable value could be:
 *       NFS_UNSTABLE,NFS_DATA_SYNC,NFS_FILE_SYNC
 *       (in nfs.proc3.write_setup and nfs.proc4.write_setup)
 * @bitmask0: V4 bitmask representing the set
 *            of attributes supported on this filesystem
 * @bitmask1: V4 bitmask representing the set
 *            of attributes supported on this filesystem
 *
 * The write_setup function is used to setup a write RPC task.
 * It is not doing the actual write operation.
 */

probe nfs.proc.write_setup = nfs.proc2.write_setup,
                             nfs.proc3.write_setup,
                             nfs.proc4.write_setup
{}
probe nfs.proc.write_setup.return = nfs.proc2.write_setup.return,
                             nfs.proc3.write_setup.return,
                             nfs.proc4.write_setup.return
{}


probe nfs.proc2.write_setup = kernel.function("nfs_proc_write_setup") !,
                              module("nfs").function("nfs_proc_write_setup") ?
{
	client = NFS_CLIENT($data->inode)
	server_ip = get_ip_from_client(client)
	prot = get_prot_from_client(client)
        version =2

        count = $data->args->count
        offset = $data->args->offset
	how = (@defined($how) ? $how : $data->args->stable)
        bitmask0 = 0
        bitmask1 = 0

	name = "nfs.proc2.write_setup"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}
probe nfs.proc2.write_setup.return = kernel.function("nfs_proc_write_setup").return !,
                              module("nfs").function("nfs_proc_write_setup").return ?
{
        version =2
	name = "nfs.proc2.write_setup.return"
	retvalue = 0
}


probe nfs.proc3.write_setup = kernel.function("nfs3_proc_write_setup") !,
                              module("nfs").function("nfs3_proc_write_setup") ?
{
	client = NFS_CLIENT($data->inode)
	server_ip = get_ip_from_client(client)
	prot = get_prot_from_client(client)
        version =3

        count = $data->args->count
        offset = $data->args->offset
	how = (@defined($how) ? $how : $data->args->stable)
        bitmask0 = 0
        bitmask1 = 0

	name = "nfs.proc3.write_setup"
	argstr = sprintf("%d,%d,%d",count,offset,how)

        size = count
        units = "bytes"
}
probe nfs.proc3.write_setup.return = kernel.function("nfs3_proc_write_setup").return !,
                              module("nfs").function("nfs3_proc_write_setup").return ?
{
        version =3
	name = "nfs.proc3.write_setup.return"
	retvalue = 0
}

probe nfs.proc4.write_setup = kernel.function("nfs4_proc_write_setup") !,
                              module("nfs").function("nfs4_proc_write_setup") ?
{
	client = NFS_CLIENT($data->inode)
	server_ip = get_ip_from_client(client)
	prot = get_prot_from_client(client)
        version =4

        count = $data->args->count
        offset = $data->args->offset
	how = (@defined($how) ? $how : $data->args->stable)
        bitmask0 = __nfsv4_bitmask($data->inode,0)
        bitmask1 = __nfsv4_bitmask($data->inode,1)
	//timestamp = $jiffies
	
	name = "nfs.proc4.write_setup"
	argstr = sprintf("%d,%d,%d",count,offset,how)

        size = count
        units = "bytes"
}
probe nfs.proc4.write_setup.return = kernel.function("nfs4_proc_write_setup").return !,
                              module("nfs").function("nfs4_proc_write_setup").return ?
{
        version =4
	name = "nfs.proc4.write_setup.return"
	retvalue = 0
}


/**
 * probe nfs.proc.write_done - NFS client response to a write RPC task
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version
 * @status: result of last operation
 * @valid: fattr->valid ,indicates which fields are valid 
 * @count: number of bytes written
 * @timestamp: V4 timestamp, which is used for lease renewal
 *
 * Fires when a reply to a write RPC task is received or some write error occurs
 * (timeout or socket shutdown).
 */
probe nfs.proc.write_done = nfs.proc2.write_done,
                            nfs.proc3.write_done,
                            nfs.proc4.write_done 
{}

probe nfs.proc.write_done.return = nfs.proc2.write_done.return,
                            nfs.proc3.write_done.return,
                            nfs.proc4.write_done.return 
{}

probe nfs.proc2.write_done = kernel.function("nfs_write_done") !,
                             module("nfs").function("nfs_write_done") ?
{
	if (@defined($data)) {		# kernels >= 2.6.10
		server_ip = __nfs_write_data_info($data,0)
	        prot = __nfs_write_data_info($data,1)
		count = __nfs_write_data_info($data, 2)
		valid = __nfs_write_data_info($data, 3)
	}
	else {
		server_ip = __nfs_write_data_info($task->tk_calldata,0)
	        prot = __nfs_write_data_info($task->tk_calldata,1)
		count = __nfs_write_data_info($task->tk_calldata, 2)
		valid = __nfs_write_data_info($task->tk_calldata, 3)
	}
	timestamp = 0
        version =2
	status = $task->tk_status

	name = "nfs.proc2.write_done"
	argstr = sprintf("%d",status)
}

probe nfs.proc2.write_done.return = kernel.function("nfs_write_done").return !,
                             module("nfs").function("nfs_write_done").return ?
{
        version =2
	name = "nfs.proc2.write_done.return"
	retstr = (@defined($return) ? sprintf("%d", $return) : "N/A")
}

probe nfs.proc3.write_done = kernel.function("nfs3_write_done") !,
                             module("nfs").function("nfs3_write_done") ?
{
	if (@defined($data)) {		# kernels >= 2.6.10
		server_ip = __nfs_write_data_info($data,0)
	        prot = __nfs_write_data_info($data,1)
		count = __nfs_write_data_info($data, 2)
		valid = __nfs_write_data_info($data, 3)
	}
	else {
		server_ip = __nfs_write_data_info($task->tk_calldata,0)
	        prot = __nfs_write_data_info($task->tk_calldata,1)
		count = __nfs_write_data_info($task->tk_calldata, 2)
		valid = __nfs_write_data_info($task->tk_calldata, 3)
	}
	timestamp = 0
        version =3
	status = $task->tk_status

	name = "nfs.proc3.write_done"
	argstr = sprintf("%d",status)
}

probe nfs.proc3.write_done.return = kernel.function("nfs3_write_done").return !,
                             module("nfs").function("nfs3_write_done").return ?
{
        version =3
	name = "nfs.proc3.write_done.return"
	retstr = (@defined($return) ? sprintf("%d", $return) : "N/A")
}

probe nfs.proc4.write_done = kernel.function("nfs4_write_done") !,
                             module("nfs").function("nfs4_write_done") ?
{
	if (@defined($data)) {		# kernels >= 2.6.10
		server_ip = __nfs_write_data_info($data,0)
	        prot = __nfs_write_data_info($data,1)
		count = __nfs_write_data_info($data, 2)
		valid = __nfs_write_data_info($data, 3)
		timestamp = __nfs_write_data_info($data, 4)
	}
	else {
		server_ip = __nfs_write_data_info($task->tk_calldata,0)
	        prot = __nfs_write_data_info($task->tk_calldata,1)
		count = __nfs_write_data_info($task->tk_calldata, 2)
		valid = __nfs_write_data_info($task->tk_calldata, 3)
		timestamp = __nfs_write_data_info($task->tk_calldata, 4)
	}
        version =4
	status = $task->tk_status

	name = "nfs.proc4.write_done"
	argstr = sprintf("%d",status)
}

probe nfs.proc4.write_done.return = kernel.function("nfs4_write_done").return !,
                             module("nfs").function("nfs4_write_done").return ?
{
        version =4
	name = "nfs.proc4.write_done.return"
	retstr = (@defined($return) ? sprintf("%d", $return) : "N/A")
}


/**
 * probe nfs.proc.commit_setup - NFS client setting up a commit RPC task
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version
 * @size: bytes in this commit
 * @count: bytes in this commit
 * @offset: the file offset
 * @bitmask0: V4 bitmask representing the set
 *            of attributes supported on this filesystem
 * @bitmask1: V4 bitmask representing the set
 *            of attributes supported on this filesystem
 *
 * The commit_setup function is used to setup a commit RPC task.
 * Is is not doing the actual commit operation.
 * It is does not exist in NFSv2.
 */

probe nfs.proc.commit_setup =nfs.proc3.commit_setup,
                             nfs.proc4.commit_setup
{}
probe nfs.proc.commit_setup.return =nfs.proc3.commit_setup.return,
                             nfs.proc4.commit_setup.return
{}



probe nfs.proc3.commit_setup = kernel.function("nfs3_proc_commit_setup") !,
                              module("nfs").function("nfs3_proc_commit_setup") ?
{
	client = NFS_CLIENT($data->inode)
	server_ip = get_ip_from_client(client)
	prot = get_prot_from_client(client)
        version =3

        count = $data->args->count
        offset = $data->args->offset
        bitmask0 = 0
        bitmask1 = 0

	name = "nfs.proc3.commit_setup"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}
probe nfs.proc3.commit_setup.return = kernel.function("nfs3_proc_commit_setup") .return!,
                              module("nfs").function("nfs3_proc_commit_setup").return ?
{
        version =3
	name = "nfs.proc3.commit_setup.return"
	retvalue = 0
}

probe nfs.proc4.commit_setup = kernel.function("nfs4_proc_commit_setup") !,
                              module("nfs").function("nfs4_proc_commit_setup") ?
{
	client = NFS_CLIENT($data->inode)
	server_ip = get_ip_from_client(client)
	prot = get_prot_from_client(client)
        version =4

        count = $data->args->count
        offset = $data->args->offset
        bitmask0 = __nfsv4_bitmask($data->inode,0)
        bitmask1 = __nfsv4_bitmask($data->inode,1)
	//timestamp = $jiffies
	
	name = "nfs.proc4.commit_setup"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}
probe nfs.proc4.commit_setup.return = kernel.function("nfs4_proc_commit_setup") .return!,
                              module("nfs").function("nfs4_proc_commit_setup").return ?
{
        version =4
	name = "nfs.proc4.commit_setup.return"
	retvalue = 0
}


/**
 * probe nfs.proc.commit_done - NFS client response to a commit RPC task
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version
 * @status: result of last operation
 * @valid: fattr->valid ,indicates which fields are valid 
 * @count: number of bytes committed
 * @timestamp: V4 timestamp, which is used for lease renewal
 *
 * Fires when a reply to a commit RPC task is received
 * or some commit operation error occur (timeout or socket shutdown).
 */
probe nfs.proc.commit_done = 
                            nfs.proc3.commit_done,
                            nfs.proc4.commit_done 
{}

probe nfs.proc.commit_done.return = 
                            nfs.proc3.commit_done.return,
                            nfs.proc4.commit_done.return 
{}


probe nfs.proc3.commit_done = kernel.function("nfs3_commit_done") !,
                             module("nfs").function("nfs3_commit_done") ?
{
	if (@defined($data)) {		# kernels >= 2.6.10
		server_ip = __nfs_write_data_info($data,0)
	        prot = __nfs_write_data_info($data,1)
		count = __nfs_write_data_info($data, 2)
		valid = __nfs_write_data_info($data, 3)
	}
	else {
		server_ip = __nfs_write_data_info($task->tk_calldata,0)
	        prot = __nfs_write_data_info($task->tk_calldata,1)
		count = __nfs_write_data_info($task->tk_calldata, 2)
		valid = __nfs_write_data_info($task->tk_calldata, 3)
	}
	timestamp = 0
        version =3
	status = $task->tk_status

	name = "nfs.proc3.commit_done"
	argstr = sprintf("%d",status)
}

probe nfs.proc3.commit_done.return = kernel.function("nfs3_commit_done").return !,
                             module("nfs").function("nfs3_commit_done").return ?
{
        version =3
	name = "nfs.proc3.commit_done.return"
	retstr = (@defined($return) ? sprintf("%d", $return) : "N/A")
}

probe nfs.proc4.commit_done = kernel.function("nfs4_commit_done") !,
                             module("nfs").function("nfs4_commit_done") ?
{
	if (@defined($data)) {		# kernels >= 2.6.10
		server_ip = __nfs_write_data_info($data,0)
	        prot = __nfs_write_data_info($data,1)
		count = __nfs_write_data_info($data, 2)
		valid = __nfs_write_data_info($data, 3)
		timestamp = __nfs_write_data_info($data, 4)
	}
	else {
		server_ip = __nfs_write_data_info($task->tk_calldata,0)
	        prot = __nfs_write_data_info($task->tk_calldata,1)
		count = __nfs_write_data_info($task->tk_calldata, 2)
		valid = __nfs_write_data_info($task->tk_calldata, 3)
		timestamp = __nfs_write_data_info($task->tk_calldata, 4)
	}
        version =4
	status = $task->tk_status

	name = "nfs.proc4.commit_done"
	argstr = sprintf("%d",status)
}

probe nfs.proc4.commit_done.return = kernel.function("nfs4_commit_done").return !,
                             module("nfs").function("nfs4_commit_done").return ?
{
        version =4
	name = "nfs.proc4.commit_done.return"
	retstr = (@defined($return) ? sprintf("%d", $return) : "N/A")
}

/**
 * probe nfs.proc.open - NFS client allocates file read/write context information
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version (the function is used for all NFS version)
 * @filename: file name
 * @flag: file flag
 * @mode: file mode
 *
 *  Allocate file read/write context information
 */
probe nfs.proc.open = kernel.function("nfs_open") !,
                      module("nfs").function("nfs_open") ?
{
	server_ip = __i2n_ip_proto($inode,0)
	prot = __i2n_ip_proto($inode,1)  	
	version = __nfs_version($inode)

	filename = __file_filename($filp)
	flag = $filp->f_flags
	mode = $filp->f_mode

	name = "nfs.proc.open"
	argstr = sprintf("%s,%d,%d",filename,flag,mode)
}

probe nfs.proc.open.return = kernel.function("nfs_open").return !,
                      module("nfs").function("nfs_open").return ?
{
	name = "nfs.proc.open.return"
	retstr = sprintf("%d", $return)
}

/**
 * probe nfs.proc.release -  NFS client releases file read/write context information
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version (the function is used for all NFS version)
 * @filename: file name
 * @flag: file flag
 * @mode: file mode
 *
 *  Release file read/write context information
 */
probe nfs.proc.release= kernel.function("nfs_release") !,
                      module("nfs").function("nfs_release") ?
{
	server_ip = __i2n_ip_proto($inode,0)
	prot = __i2n_ip_proto($inode,1)  	
	version = __nfs_version($inode)

	filename = __file_filename($filp)
	flag = $filp->f_flags
	mode = $filp->f_mode

	name = "nfs.proc.release"
	argstr = sprintf("%s,%d,%d",filename,flag,mode)
}

probe nfs.proc.release.return = kernel.function("nfs_release").return !,
                      module("nfs").function("nfs_release").return ?
{
	name = "nfs.proc.release.return"
	retstr = sprintf("%d", $return)
}

/**
 * probe nfs.proc.handle_exception - NFS client handling an NFSv4 exception
 *
 * @errorcode: indicates the type of error
 *
 * This is the error handling routine for processes for NFSv4.
 */
probe nfs.proc.handle_exception = 
                            nfs.proc4.handle_exception 
{}

probe nfs.proc.handle_exception.return = 
                            nfs.proc4.handle_exception.return 
{}

probe nfs.proc4.handle_exception = kernel.function("nfs4_handle_exception") !,
                               module("nfs").function("nfs4_handle_exception")?
{
	version =4
	
        errorcode = $errorcode

        name = "nfs.proc4.handle_exception"
        argstr =  sprintf("%d",errorcode)
}

probe nfs.proc4.handle_exception.return = kernel.function("nfs4_handle_exception").return !,
                               module("nfs").function("nfs4_handle_exception").return?
{
        name = "nfs.proc4.handle_exception.return"
        retstr =  sprintf("%d",$return)
}

/**
 * probe nfs.proc.create - NFS client creating file on server
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version (the function is used for all NFS version)
 * @fh: file handler of parent dir
 * @filename: file name
 * @filelen: length of file name
 * @flag: indicates create mode (only for NFSv3 and NFSv4)
 */
probe nfs.proc.create = nfs.proc2.create,
                        nfs.proc3.create,
                        nfs.proc4.create
{}

probe nfs.proc.create.return = nfs.proc2.create.return,
                               nfs.proc3.create.return,
                               nfs.proc4.create.return
{}

probe nfs.proc2.create = kernel.function("nfs_proc_create")!,
                         module("nfs").function("nfs_proc_create")?
{
	server_ip = __i2n_ip_proto($dir,0)
	prot = __i2n_ip_proto($dir,1)  	
	version =2

	fh = NFS_FH($dir)
	filelen = $dentry->d_name->len
	filename = kernel_string_n($dentry->d_name->name, filelen)
	mode = $sattr->ia_mode

	name = "nfs.proc2.create"
	argstr = sprintf("%s",filename)
}

probe nfs.proc2.create.return = kernel.function("nfs_proc_create").return!,
                         module("nfs").function("nfs_proc_create").return?
{
	name = "nfs.proc2.create.return"
	version =2
	retstr = sprintf("%d",$return)
}

probe nfs.proc3.create = kernel.function("nfs3_proc_create")!,
                         module("nfs").function("nfs3_proc_create")?
{
	server_ip = __i2n_ip_proto($dir,0)
	prot = __i2n_ip_proto($dir,1)  	
	version =3

	fh = NFS_FH($dir)
	filelen = $dentry->d_name->len
	filename = kernel_string_n($dentry->d_name->name, filelen)
	flag = $flags
	mode = $sattr->ia_mode

	name = "nfs.proc3.create"
	argstr = sprintf("%s",filename)
}

probe nfs.proc3.create.return = kernel.function("nfs3_proc_create").return!,
                         module("nfs").function("nfs3_proc_create").return?
{
	name = "nfs.proc3.create.return"
	version =3
	retstr = sprintf("%d",$return)
}

probe nfs.proc4.create = kernel.function("nfs4_proc_create")!,
                         module("nfs").function("nfs4_proc_create")?
{
	server_ip = __i2n_ip_proto($dir,0)
	prot = __i2n_ip_proto($dir,1)  	
	version =4

	fh = NFS_FH($dir)
	filelen = $dentry->d_name->len
	filename = kernel_string_n($dentry->d_name->name, filelen)
	flag = $flags
	mode = $sattr->ia_mode

	name = "nfs.proc4.create"
	argstr = sprintf("%s",filename)
}

probe nfs.proc4.create.return = kernel.function("nfs4_proc_create").return!,
                         module("nfs").function("nfs4_proc_create").return?
{
	name = "nfs.proc4.create.return"
	version =4
	retstr = sprintf("%d",$return)
}

/**
 * probe nfs.proc.remove - NFS client removes a file on server
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version (the function is used for all NFS version)
 * @fh: file handler of parent dir
 * @filename: file name
 * @filelen: length of file name
 */
probe nfs.proc.remove = nfs.proc2.remove,
                        nfs.proc3.remove,
                        nfs.proc4.remove
{}

probe nfs.proc.remove.return = nfs.proc2.remove.return,
                               nfs.proc3.remove.return,
                               nfs.proc4.remove.return
{}

probe nfs.proc2.remove = kernel.function("nfs_proc_remove")!,
                         module("nfs").function("nfs_proc_remove")?
{
	server_ip = __i2n_ip_proto($dir,0)
	prot = __i2n_ip_proto($dir,1)  	
	version =2

	fh = NFS_FH($dir)
	filelen = $name->len
	filename = kernel_string_n($name->name, filelen)

	name = "nfs.proc2.remove"
	argstr = sprintf("%s",filename)
}

probe nfs.proc2.remove.return = kernel.function("nfs_proc_remove").return!,
                         module("nfs").function("nfs_proc_remove").return?
{
	name = "nfs.proc2.remove.return"
	version =2
	retstr = sprintf("%d",$return)
}

probe nfs.proc3.remove = kernel.function("nfs3_proc_remove")!,
                         module("nfs").function("nfs3_proc_remove")?
{
	server_ip = __i2n_ip_proto($dir,0)
	prot = __i2n_ip_proto($dir,1)  	
	version =3

	fh = NFS_FH($dir)
	filelen = $name->len
	filename = kernel_string_n($name->name, filelen)

	name = "nfs.proc3.remove"
	argstr = sprintf("%s",filename)
}

probe nfs.proc3.remove.return = kernel.function("nfs3_proc_remove").return!,
                         module("nfs").function("nfs3_proc_remove").return?
{
	name = "nfs.proc3.remove.return"
	version =3
	retstr = sprintf("%d",$return)
}

probe nfs.proc4.remove = kernel.function("nfs4_proc_remove")!,
                         module("nfs").function("nfs4_proc_remove")?
{
	server_ip = __i2n_ip_proto($dir,0)
	prot = __i2n_ip_proto($dir,1)  	
	version =4

	fh = NFS_FH($dir)
	filelen = $name->len
	filename = kernel_string_n($name->name, filelen)

	name = "nfs.proc4.remove"
	argstr = sprintf("%s",filename)
}

probe nfs.proc4.remove.return = kernel.function("nfs4_proc_remove").return!,
                         module("nfs").function("nfs4_proc_remove").return?
{
	name = "nfs.proc4.remove.return"
	version =4
	retstr = sprintf("%d",$return)
}

/**
 * probe nfs.proc.rename - NFS client renames a file on server
 *
 * @server_ip: IP address of server
 * @prot: transfer protocol
 * @version: NFS version (the function is used for all NFS version)
 * @old_fh: file handler of old parent dir
 * @new_fh: file handler of new parent dir
 * @old_name: old file name
 * @old_filelen: length of old file name
 * @new_name: new file name
 * @new_filelen: length of new file name
 */
probe nfs.proc.rename = nfs.proc2.rename,
                        nfs.proc3.rename,
                        nfs.proc4.rename
{}

probe nfs.proc.rename.return = nfs.proc2.rename.return,
                               nfs.proc3.rename.return,
                               nfs.proc4.rename.return
{}

probe nfs.proc2.rename = kernel.function("nfs_proc_rename")!,
                         module("nfs").function("nfs_proc_rename")?
{
	server_ip = __i2n_ip_proto($old_dir,0)
	prot = __i2n_ip_proto($old_dir,1)  	
	version =2

	old_fh = NFS_FH($old_dir)
	old_filelen = $old_name->len
	old_name = kernel_string_n($old_name->name, old_filelen)
	new_fh = NFS_FH($new_dir)
	new_filelen = $new_name->len
	new_name = kernel_string_n($new_name->name, new_filelen)

	name = "nfs.proc2.rename"
	argstr = sprintf("%s,%s",old_name,new_name)
}

probe nfs.proc2.rename.return = kernel.function("nfs_proc_rename").return!,
                         module("nfs").function("nfs_proc_rename").return?
{
	name = "nfs.proc2.rename.return"
	version =2
	retstr = sprintf("%d",$return)
}

probe nfs.proc3.rename = kernel.function("nfs3_proc_rename")!,
                         module("nfs").function("nfs3_proc_rename")?
{
	server_ip = __i2n_ip_proto($old_dir,0)
	prot = __i2n_ip_proto($old_dir,1)  	
	version =3

	old_fh = NFS_FH($old_dir)
	old_filelen = $old_name->len
	old_name = kernel_string_n($old_name->name, old_filelen)
	new_fh = NFS_FH($new_dir)
	new_filelen = $new_name->len
	new_name = kernel_string_n($new_name->name, new_filelen)

	name = "nfs.proc3.rename"
	argstr = sprintf("%s,%s",old_name,new_name)
}

probe nfs.proc3.rename.return = kernel.function("nfs3_proc_rename").return!,
                         module("nfs").function("nfs3_proc_rename").return?
{
	name = "nfs.proc3.rename.return"
	version =3
	retstr = sprintf("%d",$return)
}

probe nfs.proc4.rename = kernel.function("nfs4_proc_rename")!,
                         module("nfs").function("nfs4_proc_rename")?
{
	server_ip = __i2n_ip_proto($old_dir,0)
	prot = __i2n_ip_proto($old_dir,1)  	
	version =4

	old_fh = NFS_FH($old_dir)
	old_filelen = $old_name->len
	old_name = kernel_string_n($old_name->name, old_filelen)
	new_fh = NFS_FH($new_dir)
	new_filelen = $new_name->len
	new_name = kernel_string_n($new_name->name, new_filelen)

	name = "nfs.proc4.rename"
	argstr = sprintf("%s,%s",old_name,new_name)
}

probe nfs.proc4.rename.return = kernel.function("nfs4_proc_rename").return!,
                         module("nfs").function("nfs4_proc_rename").return?
{
	name = "nfs.proc4.rename.return"
	version =4
	retstr = sprintf("%d",$return)
}
