# Utrace compile (pass 4) tests.  We can't run these as
# testsuite/buildok tests, since if the current kernel has no utrace
# support, those will fail - but not because of a problem with
# systemtap's utrace probes (but because of the lack of utrace).  So,
# this test script checks for the existence of utrace in the kernel.
# If utrace exists in the kernel, it tries some compile tests.  If
# utrace doesn't exist in the kernel, marks the tests as 'untested'.

# stap_compile TEST_NAME flags script args
# - TEST_NAME is the name of the current test
# - compile indicates whether the script is supposed to compile
# - script is the script to compile
# Additional arguments are passed to stap as-is.
proc stap_compile { TEST_NAME compile script args } {
    set cmd [concat {stap -v -p4 -e} $script $args]
    
    verbose -log "running $cmd" 
    eval spawn $cmd
    set compile_errors 0
    expect {
	-re {^Pass\ [1234]:[^\r]*\ in\ .*\ ms.\r\n} {exp_continue}
	-re {^Pass\ [34]: using cached [^\r\n]+\r\n} {exp_continue}
        # pass-4 output
	-re {^/[^\r\n]+.ko\r\n} {exp_continue}
	-re "parse error" { incr compile_errors 1; exp_continue}
	-re "compilation failed" {incr compile_errors 1; exp_continue}
	-re "semantic error:" {incr compile_errors 1; exp_continue}
	-re "terminate called" {incr compile_errors 1; exp_continue}
    }
    catch close
    wait

    # If we've got compile errors and the script was supposed to
    # compile, fail.
    if {$compile_errors > 0} {
	if {$compile == 1} {
	    fail "$TEST_NAME compilation failed"
	} else {
	    pass "$TEST_NAME compilation failed correctly"
	}
    } else {
	if {$compile == 1} {
	    pass "$TEST_NAME compilation succeeded"
	} else {
	    fail "$TEST_NAME compilation succeeded unexpectedly"
	}
    }
}

# Initialize variables
set utrace_support_found 0

set begin_script {"probe process(\"/bin/ls\").begin { print(\"ls begin\") }"}
set end_script {"probe process(\"/bin/ls\").end { print(\"ls end\") }"}
set syscall_script {"probe process(\"/bin/ls\").syscall { printf(\"|%d\", \$syscall) }"}
set syscall_return_script {"probe process(\"/bin/ls\").syscall.return { printf(\"|%d\", \$syscall) }"}
set thread_begin_script {"probe process(\"/bin/ls\").thread.begin { print(\"ls thread.begin\") }"}
set thread_end_script {"probe process(\"/bin/ls\").thread.end { print(\"ls thread.end\") }"}

set pid_begin_script {"probe process(123).begin { print(\"123 begin\") }"}
set pid_end_script {"probe process(123).end { print(\"123 end\") }"}
set pid_syscall_script {"probe process(123).syscall { printf(\"|%d\", \$syscall) }"}
set pid_syscall_return_script {"probe process(123).syscall.return { printf(\"|%d\", \$syscall) }"}
set pid_thread_begin_script {"probe process(123).thread.begin { print(\"123 thread.begin\") }"}
set pid_thread_end_script {"probe process(123).thread.end { print(\"123 thread.end\") }"}

# Try to find utrace_attach symbol in /proc/kallsyms
set path "/proc/kallsyms"
if {! [catch {exec grep -q utrace_attach $path} dummy]} {
    set utrace_support_found 1
}

#
# Do some utrace compile tests.
#

set TEST_NAME "UTRACE_P4_01"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a begin script using a path
    stap_compile $TEST_NAME 1 $begin_script
}

set TEST_NAME "UTRACE_P4_01_pid"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a begin script using a pid
    stap_compile $TEST_NAME 1 $pid_begin_script
}

set TEST_NAME "UTRACE_P4_02"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a end script using a path
    stap_compile $TEST_NAME 1 $end_script
}

set TEST_NAME "UTRACE_P4_02_pid"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a end script using a pid
    stap_compile $TEST_NAME 1 $pid_end_script
}

set TEST_NAME "UTRACE_P4_03"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a syscall script using a path
    stap_compile $TEST_NAME 1 $syscall_script
}

set TEST_NAME "UTRACE_P4_03_pid"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a syscall script using a pid
    stap_compile $TEST_NAME 1 $pid_syscall_script
}

set TEST_NAME "UTRACE_P4_04"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a syscall return script using a path
    stap_compile $TEST_NAME 1 $syscall_return_script
}

set TEST_NAME "UTRACE_P4_04_pid"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling a syscall return script using a pid
    stap_compile $TEST_NAME 1 $pid_syscall_return_script
}

set TEST_NAME "UTRACE_P4_05"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling an thread.begin script using a path
    stap_compile $TEST_NAME 1 $thread_begin_script
}

set TEST_NAME "UTRACE_P4_05_pid"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling an thread.begin script using a pid
    stap_compile $TEST_NAME 1 $pid_thread_begin_script
}

set TEST_NAME "UTRACE_P4_06"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling an thread.end script using a path
    stap_compile $TEST_NAME 1 $thread_end_script
}

set TEST_NAME "UTRACE_P4_06_pid"
if {$utrace_support_found == 0} {
    untested "$TEST_NAME : no kernel utrace support found"
} else {
    # Try compiling an thread.end script using a pid
    stap_compile $TEST_NAME 1 $pid_thread_end_script
}
