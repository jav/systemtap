# stap_run TEST_NAME LOAD_GEN_FUNCTION OUTPUT_CHECK_STRING
# TEST_NAME is path to the current test
# LOAD_GEN_FUNCTION (optional) to produce something to measure
#     returns 0 if successful
#     returns 1 if there was a problem
# OUTPUT_CHECK_STRING (optional) examines the output of experiment
#     returns 0 if successful
#     returns 1 if there was a problem
# Additional arguments are passed to stap as-is.
#
# As a side-effect, global 'probe_errors' and 'skipped_probes' are set
# to the number of probe errors and skipped probes seen while
# running the probe.
proc stap_run { TEST_NAME {LOAD_GEN_FUNCTION ""} {OUTPUT_CHECK_STRING ""} args } {
    global probe_errors
    global skipped_probes

    # zap the srcdir prefix
    set test_file_name $TEST_NAME
    set TEST_NAME [regsub {.*/testsuite/} $TEST_NAME ""]

    # initialize probe_errors and skipped_probes to 0
    set probe_errors 0
    set skipped_probes 0

    if {[info procs installtest_p] != "" && ![installtest_p]} { untested $TEST_NAME; return }

    set cmd [concat {stap -v} $args]
    if [file readable $test_file_name] {
        lappend cmd $test_file_name
    }
    eval spawn $cmd
    expect {
	-timeout 180
	-re {^Pass\ ([1234]):[^\r]*\ in\ ([0-9]+)usr/([0-9]+)sys/([0-9]+)real\ ms\.\r\n}
	{set pass$expect_out(1,string) "\t$expect_out(2,string)\t$expect_out(3,string)\t$expect_out(4,string)"; exp_continue}
	-re {^Pass\ ([34]): using cached [^\r]+\r\n}
	{set pass$expect_out(1,string) "\t0\t0\t0"; exp_continue}
	-re {^Pass 5: starting run.\r\n} {exp_continue}
	-re "^systemtap starting probe\r\n" {
	    pass "$TEST_NAME startup"
	    if {$LOAD_GEN_FUNCTION != ""} then {
		#run the interesting test here
		if {[eval $LOAD_GEN_FUNCTION] == 0} then {
		    pass "$TEST_NAME load generation"
		} else {
		    fail "$TEST_NAME load generation"
		}
	    }

	    send "\003"

	    # check the output to see if it is sane
	    set output "^systemtap ending probe\r\n$OUTPUT_CHECK_STRING"

	    expect {
		-timeout 20
		-re  $output {
		    pass "$TEST_NAME shutdown and output"
		    expect {
			-timeout -1
			-re {^Pass\ ([5]):[^\r]*\ in\ ([0-9]+)usr/([0-9]+)sys/([0-9]+)real\ ms\.\r\n}
			{set pass$expect_out(1,string) "\t$expect_out(2,string)\t$expect_out(3,string)\t$expect_out(4,string)"
			    verbose -log "metric:\t$TEST_NAME $pass1$pass2$pass3$pass4$pass5"}
			-re {^WARNING: Number of errors: ([0-9]+), skipped probes: ([0-9]+)\r\n}
			{set probe_errors $expect_out(1,string)
			 set skipped_probes $expect_out(2,string)}
		    }
		}
		timeout { fail "$TEST_NAME shutdown (timeout)" }
		eof { fail "$TEST_NAME shutdown (eof)" }
	    }
	}
	-re "semantic error:" { fail "$TEST_NAME compilation" }
	timeout { fail "$TEST_NAME startup (timeout)"; send "\003" }
	eof { fail "$TEST_NAME startup (eof)" }
    }
  catch close
  wait
}

proc no_load {} {
# nothing in here
# load to use when nothing is needed
    return 0
}

# tests better all be true
set all_pass_string "(systemtap test success\r\n)+$"
