.\" -*- nroff -*-
.TH STAP 1 @DATE@ "Red Hat"
.SH NAME
stap \- systemtap script translator/driver

.\" macros
.de SAMPLE
.br
.RS
.nf
.nh
..
.de ESAMPLE
.hy
.fi
.RE
..

.SH SYNOPSIS

.br
.B stap
[
.I OPTIONS
]
.I FILENAME
[
.I ARGUMENTS
]
.br
.B stap
[
.I OPTIONS
]
.B \-
[
.I ARGUMENTS
]
.br
.B stap
[
.I OPTIONS
]
.BI \-e " SCRIPT"
[
.I ARGUMENTS
]

.SH DESCRIPTION

The
.IR stap
program is the front-end to the Systemtap tool.  It accepts probing
instructions (written in a simple scripting language), translates
those instructions into C code, compiles this C code, and loads the
resulting kernel module into a running Linux kernel to perform the
requested system trace/probe functions.  You can supply the script in
a named file, from standard input, or from the command line.  The
program runs until it is interrupted by the user, or if the script
voluntarily invokes the
.I exit()
function, or by sufficient number of soft errors.
.PP
The language, which is described in a later section, is strictly typed,
declaration free, procedural, and inspired by
.IR awk .
It allows source code points or events in the kernel to be associated
with handlers, which are subroutines that are executed synchronously.  It is
somewhat similar conceptually to "breakpoint command lists" in the
.IR gdb
debugger.
.PP
This manual corresponds to version @VERSION@.

.SH OPTIONS
The systemtap translator supports the following options.  Any other option
prints a list of supported options.
.\" undocumented for now:
.\" \-t test mode
.TP
.B \-v
Increase verbosity.  Produce a larger volume of informative (?) output
each time option repeated.
.TP
.B \-h
Show help message.
.TP
.B \-V
Show version message.
.TP
.B \-k
Keep the temporary directory after all processing.  This may be useful
in order to examine the generated C code, or to reuse the compiled
kernel object.
.TP
.B \-g
Guru mode.  Enable parsing of unsafe expert-level constructs like
embedded C.
.TP
.B \-u
Unoptimized mode.  Disable unused code elision during elaboration.
.TP
.BI \-b
Use relayfs-based bulk mode for kernel-to-user data transfer.
.TP
.BI \-M
Don't merge per-cpu files when using bulk (relayfs) mode. This option is
valid for bulk mode.
.TP
.B \-t
Collect timing information on the number of times probe executes
and average amount of time spent in each probe.
.TP
.BI \-s NUM
Use NUM megabyte buffers for kernel-to-user data transfer.  On a
multiprocessor in bulk mode, this is a per-processor amount.
.TP
.BI \-p " NUM"
Stop after pass NUM.  The passes are numbered 1-5: parse, elaborate,
translate, compile, run.  See the
.B PROCESSING
section for details.
.TP
.BI \-I " DIR"
Add the given directory to the tapset search directory.  See the
description of pass 2 for details.
.TP
.BI \-D " NAME=VALUE"
Add the given C preprocessor directive to the module Makefile.  These can 
be used to override limit parameters described below.
.TP
.BI \-R " DIR"
Look for the systemtap runtime sources in the given directory.
.TP
.BI \-r " RELEASE"
Build for given kernel release instead of currently running one.
.TP
.BI \-m " MODULE"
Use the given name for the generated kernel object module, instead
of a unique randomized name.
.TP
.BI \-o " FILE"
Send standard output to named file.
.TP
.BI \-c " CMD"
Start the probes, run CMD, and exit when CMD finishes.
.TP
.BI \-x " PID"
Sets target() to PID. This allows scripts to be written that filter on 
a specific process.

.SH ARGUMENTS

Any additional arguments on the command line are passed to the script
parser for substitution.  See below.

.SH SCRIPT LANGUAGE

The systemtap script language resembles 
.IR awk .
There are two main outermost constructs: probes and functions.  Within
these, statements and expressions use C-like operator syntax and
precedence.

.SS GENERAL SYNTAX
Whitespace is ignored.  Three forms of comments are supported:
.RS
.br
.BR # " ... shell style, to the end of line"
.br
.BR // " ... C++ style, to the end of line"
.br
.BR /* " ... C style ... " */
.RE
Literals are either strings enclosed in double-quotes (passing through
the usual C escape codes with backslashes), or integers (in decimal,
hexadecimal, or octal, using the same notation as in C).  All strings
are limited in length to some reasonable value (a few hundred bytes).
Integers are 64-bit signed quantities, although the parser also accepts
(and wraps around) values above positive 2**63.
.PP
In addition, script arguments given at the end of the command line may
be expanded as literals.  Use
.B $1 ... $<NN>
for casting as a numeric literal and
.B @1 ... @<NN>
for casting as string literal.  These may be used in all contexts
where literals are accepted.  Reference to an argument number beyond
what was actually given is an error.
.PP
A simple conditional preprocessing stage is run as a part of parsing.
The general form is similar to the 
.RB cond " ? " exp1 " : " exp2
ternary operator:
.SAMPLE
.BR %( " CONDITION " %? " TRUE-TOKENS " %)
.BR %( " CONDITION " %? " TRUE-TOKENS " %: " FALSE-TOKENS " %)
.ESAMPLE
The CONDITION is a very limited expression whose format is determined
by its first keyword.
.PP
If the first part is the identifier
.BR kernel_vr " or " kernel_v
to refer to the kernel version number, with ("2.6.13\-1.322FC3smp") or
without ("2.6.13") the release code suffix, then
the second part is one of the six standard numeric comparison operators
.BR < ", " <= ", " == ", " != ", " > ", and " >= ,
and the third part is a string literal that contains an RPM-style
version-release value.  The condition is deemed satisfied if the
version of the target kernel (as optionally overridden by the
.BR \-r
option) compares to the given version string.  The comparison is
performed by the glibc function
.BR strverscmp .
.PP
If, on the other hand, the first part is the identifier
.BR arch
to refer to the processor architecture, then the second part
then the second part is one of the two string comparison operators
.BR == " or " != ,
and the third part is a string literal for matching it.  This
comparison is simple string (in)equality.
.PP
The TRUE-TOKENS and FALSE-TOKENS are zero or more general parser
tokens (possibly including nested preprocessor conditionals), and are
pasted into the input stream if the condition is true or false.  For
example, the following code induces a parse error unless the target
kernel version is newer than 2.6.5:
.SAMPLE
%( kernel_v <= "2.6.5" %? **ERROR** %) # invalid token sequence
.ESAMPLE
The following code might adapt to hypothetical kernel version drift:
.SAMPLE
probe kernel.function ( 
  %( kernel_v <= "2.6.12" %? "__mm_do_fault" %: 
     %( kernel_vr == "2.6.13\-1.8273FC3smp" %? "do_page_fault" %:
        UNSUPPORTED %) %)
) { /* ... */ }

%( arch == "ia64" %?
   probe syscall.vliw = kernel.function("vliw_widget") {} 
%)
.ESAMPLE

.SS VARIABLES
Identifiers for variables and functions are an alphanumeric sequence,
and may include "_" and "$" characters.  They may not start with a
plain digit, as in C.  Each variable is by default local to the probe
or function statement block within which it is mentioned, and therefore
its scope and lifetime is limited to a particular probe or function
invocation.
.\" XXX add statistics type here once it's supported
.PP
Scalar variables are implicitly typed as either string or integer.
Associative arrays also have a string or integer value, and a
a tuple of strings and/or integers serving as a key.
The translator performs
.I type inference
on all identifiers, including array indexes and function parameters.
Inconsistent type-related use of identifiers signals an error.
.PP
Variables may be declared global, so that they are shared amongst all
probes and live as long as the entire systemtap session.  There is one
namespace for all global variables, regardless of which script file
they are found within.  A global declaration may be written at the
outermost level anywhere, not within a block of code.  The following
declaration marks a few variables as global.  The translator will
infer for each its value type, and if it is used as an array, its key
types.  Optionally, scalar globals may be initialized with a string
or number literal.
.RS
.BR global " var1" , " var2" , " var3=4"
.RE
.\" XXX add statistics type here once it's supported

.SS STATEMENTS
Statements enable procedural control flow.  They may occur within
functions and probe handlers.  The total number of statements executed
in response to any single probe event is limited to some number
defined by a macro in the translated C code, and is in the
neighbourhood of 1000.
.TP
EXP
Execute the string- or integer-valued expression and throw away
the value.
.TP
.BR { " STMT1 STMT2 ... " }
Execute each statement in sequence in this block.  Note that 
separators or terminators are generally not necessary between statements.
.TP
.BR ;
Null statement, do nothing.  It is useful as an optional separator between
statements to improve syntax-error detection and to handle certain
grammar ambiguities.
.TP
.BR if " (EXP) STMT1 [ " else " STMT2 ]"
Compare integer-valued EXP to zero.  Execute the first (non-zero)
or second STMT (zero).
.TP
.BR while " (EXP) STMT"
While integer-valued EXP evaluates to non-zero, execute STMT.
.TP
.BR for " (EXP1; EXP2; EXP3) STMT"
Execute EXP1 as initialization.  While EXP2 is non-zero, execute
STMT, then the iteration expression EXP3.
.TP
.BR foreach " (VAR " in " ARRAY [ "limit " EXP ]) STMT"
Loop over each element of the named global array, assigning current
key to VAR.  The array may not be modified within the statement.
By adding a single 
.BR + " or " \-
operator after the VAR or the ARRAY identifier, the iteration will
proceed in a sorted order, by ascending or descending index or value.

Using the optional
.BR limit 
keyword limits the number of loop iterations to EXP times.  EXP is
evaluted once at the beginning of the loop.
.TP
.BR foreach " ([VAR1, VAR2, ...] " in " ARRAY [ "limit " EXP ]) STMT"
Same as above, used when the array is indexed with a tuple of keys.
A sorting suffix may be used on at most one VAR or ARRAY identifier.
.TP
.BR break ", " continue
Exit or iterate the innermost nesting loop
.RB ( while " or " for " or " foreach )
statement.
.TP
.BR return " EXP"
Return EXP value from enclosing function.  If the function's value is
not taken anywhere, then a return statement is not needed, and the
function will have a special "unknown" type with no return value.
.TP
.BR next
Return now from enclosing probe handler.
.TP
.BR delete " ARRAY[INDEX1, INDEX2, ...]"
Remove from ARRAY the element specified by the index tuple.  The value will no
longer be available, and subsequent iterations will not report the element.
It is not an error to delete an element that does not exist.
.TP
.BR delete " ARRAY"
Remove all elements from ARRAY.
.TP
.BR delete " SCALAR"
Removes the value of SCALAR.  Integers and strings are cleared to 0 and ""
respectively, while statistics are reset to the initial empty state.

.SS EXPRESSIONS
Systemtap supports a number of operators that have the same general syntax,
semantics, and precedence as in C and awk.  Arithmetic is performed as per
typical C rules for signed integers.  Division by zero or overflow is
detected and results in an error.
.TP
binary numeric operators
.B * / % + \- >> << & ^ | && ||
.TP
binary string operators
.B .
(string concatenation)
.TP
numeric assignment operators
.B = *= /= %= += \-= >>= <<= &= ^= |=
.TP
string assignment operators
.B = .=
.TP
unary numeric operators
.B + \- ! ~ ++ \-\- 
.TP
binary numeric or string comparison operators
.B < > <= >= == !=
.TP
ternary operator
.RB cond " ? " exp1 " : " exp2
.TP
grouping operator
.BR ( " exp " )
.TP
function call
.RB "fn " ( "[ arg1, arg2, ... ]" )

.SS PROBES
The main construct in the scripting language identifies probes.
Probes associate abstract events with a statement block ("probe
handler") that is to be executed when any of those events occur.  The
general syntax is as follows:
.SAMPLE
.BR probe " PROBEPOINT [" , " PROBEPOINT] " { " [STMT ...] " }
.ESAMPLE
.PP
Events are specified in a special syntax called "probe points".  There
are several varieties of probe points defined by the translator, and
tapset scripts may define further ones using aliases.  These are
listed in the
.IR stapprobes (5)
manual pages.
.PP
The probe handler is interpreted relative to the context of each
event.  For events associated with kernel code, this context may
include
.I variables
defined in the 
.I source code
at that spot.  These "target variables" are presented to the script as
variables whose names are prefixed with "$".  They may be accessed
only if the kernel's compiler preserved them despite optimization.
This is the same constraint that a debugger user faces when working
with optimized code.  Some other events have very little context.
.PP
New probe points may be defined using "aliases".  Probe point aliases
look similar to probe definitions, but instead of activating a probe
at the given point, it just defines a new probe point name as an alias
to an existing one. There are two types of alias, i.e. the prologue 
style and the epilogue style which are identified by "=" and "+="
respectively. 
.PP
For prologue style alias, the statement block that follows an alias
definition is implicitly added as a prologue to any probe that refers
to the alias. While for the epilogue style alias, the statement block
that follows an alias definition is implicitly added as an epilogue to
any probe that refers to the alias. For example:

.SAMPLE
probe syscall.read = kernel.function("sys_read") {
  fildes = $fd
}
.ESAMPLE
defines a new probe point
.nh
.IR syscall.read ,
.hy
which expands to
.nh
.IR kernel.function("sys_read") ,
.hy
with the given statement as a prologue. And 
.SAMPLE
probe syscall.read += kernel.function("sys_read") {
  fildes = $fd
}
.ESAMPLE
defines a new probe point with the given statement as an epilogue. 

Another probe definition
may use the alias like this:
.SAMPLE
probe syscall.read {
  printf("reading fd=%d\n", fildes)
}
.ESAMPLE

.SS FUNCTIONS
Systemtap scripts may define subroutines to factor out common work.
Functions take any number of scalar (integer or string) arguments, and
must return a single scalar (integer or string).  An example function
declaration looks like this:
.SAMPLE
function thisfn (arg1, arg2) {
   return arg1 + arg2
}
.ESAMPLE
Note the general absence of type declarations, which are instead
inferred by the translator.  However, if desired, a function
definition may include explicit type declarations for its return value
and/or its arguments.  This is especially helpful for embedded-C
functions.  In the following example, the type inference engine need
only infer type type of arg2 (a string).
.SAMPLE
function thatfn:string (arg1:long, arg2) {
   return sprint(arg1) . arg2
}
.ESAMPLE
Functions may call others or themselves
recursively, up to a fixed nesting limit.  This limit is defined by
a macro in the translated C code and is in the neighbourhood of 10.

.SS PRINTING
The function names
.IR print ", " printf ", " sprint ", and " sprintf
are specially treated by the translator.  They format values for
printing to the standard systemtap log stream in a more convenient
way.
.PP
.TP
print
takes a single value of any type, and prints it
.TP
sprint
operates like
.IR print ,
but returns the formatted string instead of logging it.
.TP
printf
takes a formatting string, and a number of values of corresponding types,
and prints them all.
.TP
sprintf
operates like
.IR printf ,
but like
.IR sprint ,
returns the formatted string instead of logging it.
.PP
The
.IR printf
formatting directives similar to those of C, except that they are
fully type-checked by the translator.
.SAMPLE
	x = sprintf("take %d steps forward, %d steps back\\n", 3, 2)
	printf("take %d steps forward, %d steps back\\n", 3+1, 2*2)
	bob = "bob"
	alice = "alice"
	print(bob)
	print("hello")
	print(10)
	printf("%s phoned %s %.4x times\\n", bob, alice . bob, 3456)
	printf("%s except after %s\\n", 
		sprintf("%s before %s", 
			sprint(1), sprint(3)), 
		sprint("C"))
.ESAMPLE

.SS STATISTICS
It is often desirable to collect statistics in a way that avoids the
penalties of repeatedly exclusive locking the global variables those
numbers are being put into.  Systemtap provides a solution using a
special operator to accumulate values, and several pseudo-functions to
extract the statistical aggregates.
.PP
The aggregation operator is
.IR <<< ,
and resembles an assignment, or a C++ output-streaming operation.
The left operand specifies a scalar or array-index lvalue, which must
be declared global.  The right operand is a numeric expression.  The
meaning is intuitive: add the given number to the pile of numbers to
compute statistics of.  (The specific list of statistics to gather
is given separately, by the extraction functions.)
.SAMPLE
    foo <<< 1
    stats[pid()] <<< memsize
.ESAMPLE
.PP
The extraction functions are also special.  For each appearance of a
distinct extraction function operating on a given identifier, the
translator arranges to compute a set of statistics that satisfy it.
The statistics system is thereby "on-demand".  Each execution of
an extraction function causes the aggregation to be computed for
that moment across all processors. 
.PP
Here is the set of extractor functions.  The first argument of each is
the same style of lvalue used on the left hand side of the accumulate
operation.  The
.IR @count(v) ", " @sum(v) ", " @min(v) ", " @max(v) ", " @avg(v)
extractor functions compute the number/total/minimum/maximum/average
of all accumulated values.  The resulting values are all simple
integers.
.PP
Histograms are also available, but are more complicated because they
have a vector rather than scalar value.
.I @hist_linear(v,L,H,W)
represents a linear histogram whose low/high/width parameters are
given by the following three literal numbers.  Similarly,
.I @hist_log(v,N)
represents a base-2 logarithmic histogram with the given number of
buckets.  N may be omitted, and defaults to 64.  Printing a histogram
with the
.I print
family of functions renders a histogram object as a tabular
"ASCII art" bar chart.
.SAMPLE
probe foo {
  x <<< $value
}
probe end {  
  printf ("avg %d = sum %d / count %d\\n",
          @avg(x), @sum(x), @count(x))
  print (@hist_log(v))
}
.ESAMPLE

.SS EMBEDDED C
When in guru mode, the translator accepts embedded code in the
script.  Such code is enclosed between
.IR %{
and
.IR %}
markers, and is transcribed verbatim, without analysis, in some
sequence, into the generated C code.  At the outermost level, this may
be useful to add
.IR #include
instructions, and any auxiliary definitions for use by other embedded
code.  
.PP
The other place where embedded code is permitted is as a function body.
In this case, the script language body is replaced entirely by a piece
of C code enclosed again between
.IR %{ " and " %}
markers.
This C code may do anything reasonable and safe.  There are a number
of undocumented but complex safety constraints on concurrency,
resource consumption, and runtime limits, so this is an advanced
technique.
.PP
The memory locations set aside for input and output values
are made available to it using a macro
.IR THIS .
Here are some examples:
.SAMPLE
function add_one (val) %{
  THIS\->__retvalue = THIS\->val + 1;
%}
function add_one_str (val) %{
  strlcpy (THIS\->__retvalue, THIS\->val, MAXSTRINGLEN);
  strlcat (THIS\->__retvalue, "one", MAXSTRINGLEN);
%}
.ESAMPLE
The function argument and return value types have to be inferred by
the translator from the call sites in order for this to work.  The
user should examine C code generated for ordinary script-language
functions in order to write compatible embedded-C ones.

.SS BUILT-INS
A set of builtin functions and probe point aliases are provided
by the scripts installed under the
.nh
.IR /usr/share/systemtap/tapset
.hy
directory.  These are described in the
.IR stapfuncs "(5) and " stapprobes (5)
manual pages.

.SH PROCESSING
The translator begins pass 1 by parsing the given input script,
and all scripts (files named
.IR *.stp )
found in a tapset directory.  The directories listed
with
.BR \-I
are processed in sequence, each processed in "guru mode".  For each
directory, a number of subdirectories are also searched.  These
subdirectories are derived from the selected kernel version (the
.BR \-R
option),
in order to allow more kernel-version-specific scripts to override less
specific ones.  For example, for a kernel version
.IR 2.6.12\-23.FC3
the following patterns would be searched, in sequence:
.IR 2.6.12\-23.FC3/*.stp ,
.IR 2.6.12/*.stp ,
.IR 2.6/*.stp ,
and finally
.IR *.stp
Stopping the translator after pass 1 causes it to print the parse trees. 

.PP
In pass 2, the translator analyzes the input script to resolve symbols
and types.  References to variables, functions, and probe aliases that
are unresolved internally are satisfied by searching through the
parsed tapset scripts.  If any tapset script is selected because it
defines an unresolved symbol, then the entirety of that script is
added to the translator's resolution queue.  This process iterates
until all symbols are resolved and a subset of tapset scripts is
selected.
.PP
Next, all probe point descriptions are validated 
against the wide variety supported by the translator.  Probe points that
refer to code locations ("synchronous probe points") require the
appropriate kernel debugging information to be installed.  In the
associated probe handlers, target-side variables (whose names begin
with "$") are found and have their run-time locations decoded.
.PP
Next, all probes and functions are analyzed for optimization
opportunities, in order to remove variables, expressions, and
functions that have no useful value and no side-effect.  Embedded-C
functions are assumed to have side-effects unless they include the
magic string
.BR /*\ pure\ */ .
Since this optimization can hide latent code errors such as type
mismatches or invalid $target variables, it sometimes may be useful
to disable the optimizations with the
.BR \-u
option. 
.PP
Finally, all variable, function, parameter, array, and index types are
inferred from context (literals and operators).  Stopping the
translator after pass 2 causes it to list all the probes, functions,
and variables, along with all inferred types.  Any inconsistent or
unresolved types cause an error.

.PP
In pass 3, the translator writes C code that represents the actions
of all selected script files, and creates a
.IR Makefile
to build that into a kernel object.  These files are placed into a
temporary directory.  Stopping the translator at this point causes
it to print the contents of the C file.

.PP
In pass 4, the translator invokes the Linux kernel build system to
create the actual kernel object file.  This involves running
.IR make
in the temporary directory, and requires a kernel module build
system (headers, config and Makefiles) to be installed in the usual
spot
.IR /lib/modules/VERSION/build .
Stopping the translator after pass 4 is the last chance before
running the kernel object.  This may be useful if you want to
archive the file.

.PP
In pass 5, the translator invokes the systemtap auxiliary program
.I staprun
program for the given kernel object.  This program arranges to load
the module then communicates with it, copying trace data from the
kernel into temporary files, until the user sends an interrupt signal.
Any run-time error encountered by the probe handlers, such as running
out of memory, division by zero, exceeding nesting or runtime limits,
results in a soft error indication.  Soft errors in excess of
MAXERRORS block of all subsequent probes, and terminate the session.
Finally, staprun unloads the module, and cleans up.

.SH EXAMPLES
See the 
.IR stapex (5)
manual page for a collection of samples.

.SH CACHING
The systemtap translator caches the pass 3 output (the generated C
code) and the pass 4 output (the compiled kernel module) if pass 4
completes successfully.  This cached output is reused if the same
script is translated again assuming the same conditions exist (same kernel
version, same systemtap version, etc.).  Cached files are stored in
the
.I $SYSTEMTAP_DIR/cache
directory.

.SH SAFETY AND SECURITY
Systemtap is an administrative tool.  It exposes kernel internal data
structures and potentially private user information.  It acquires root
privileges to actually run the kernel objects it builds using the
.IR sudo
command applied to the
.IR staprun
program.  The latter is a part of the Systemtap package, dedicated to
module loading and unloading (but only in the white zone), and
kernel-to-user data transfer.  Since 
.IR staprun
does not perform any additional security checks on the kernel objects
it is given, it would be unwise for a system administrator to give
even targeted
.IR sudo
privileges to untrusted users.
.PP
The translator asserts certain safety constraints.  It aims to ensure
that no handler routine can run for very long, allocate memory,
perform unsafe operations, or in unintentionally interfere with the
kernel.  Use of script global variables is suitably locked to protect
against manipulation by concurrent probe handlers.  Use of guru mode
constructs such as embedded C can violate these constraints, leading
to kernel crash or data corruption.
.PP
The resource use limits are set by macros in the generated C code.
These may be overridden with the
.BR \-D
flag.  A selection of these is as follows: 
.TP
MAXNESTING
Maximum number of recursive function call levels.
.TP
MAXSTRINGLEN
Maximum length of strings.
.TP
MAXTRYLOCK
Maximum number of iterations to wait for locks on global variables
before declaring possible deadlock and skipping the probe.
.TP
MAXACTION
Maximum number of statements to execute during any single probe hit.
.TP
MAXMAPENTRIES
Maximum number of rows in any single global array.
.TP
MAXERRORS
Maximum number of soft errors before an exit is triggered.
.TP
MAXSKIPPED
Maximum number of skipped reentrant probes before an exit is triggered.

.PP
In case something goes wrong with 
.IR stap " or " staprun
after a probe has already started running, one may safely kill both
user processes, and remove the active probe kernel module with
.IR rmmod .
Any pending trace messages may be lost.

.SH FILES
.\" consider autoconf-substituting these directories
.TP
~/.systemtap
Systemtap data directory for cached systemtap files, unless overridden
by the
.I SYSTEMTAP_DIR
environment variable.
.TP
/tmp/stapXXXXXX
Temporary directory for systemtap files, including translated C code
and kernel object.
.TP
/usr/share/systemtap/tapset 
The automatic tapset search directory, unless overridden by
the
.I SYSTEMTAP_TAPSET
environment variable.
.TP
/usr/share/systemtap/runtime
The runtime sources, unless overridden by the
.I SYSTEMTAP_RUNTIME
environment variable.
.TP
/lib/modules/VERSION/build
The location of kernel module building infrastructure.
.TP
/usr/lib/debug/lib/modules/VERSION
The location of kernel debugging information when packaged into the
.IR kernel\-debuginfo
RPM.
.TP
/usr/bin/staprun
The auxiliary program supervising module loading, interaction, and
unloading.

.SH SEE ALSO
.IR stapprobes (5),
.IR stapfuncs (5),
.IR stapex (5),
.IR lket (5),
.IR dprobes (1),
.IR awk (1),
.IR sudo (8),
.IR elfutils (3),
.IR gdb (1)

.SH BUGS
There are numerous missing features and possibly numerous bugs.  Use
the Bugzilla link off of the project web page:
.nh
.BR http://sources.redhat.com/systemtap/ .
.hy

.SH AUTHORS
The
.IR stap
translator was written by Frank Ch. Eigler and Graydon Hoare.  The
kernel-side runtime library and the user-level
.IR staprun
daemon was written by Martin Hunt and Tom Zanussi.  Contact them
using the public mailing list:
.nh
.BR <systemtap@sources.redhat.com> .
.hy

.SH ACKNOWLEDGEMENTS
The primary probing mechanism uses IBM's
.IR kprobes ,
and
.IR relayfs
packages, which were improved and ported by IBM and Intel staff.
The elfutils library from Ulrich Drepper and Roland McGrath is used
to process dwarf debugging information.  Many project members contributed
to the overall design and priorities of the system, including Will Cohen,
Jim Keniston, Vara Prasad, and Brad Chen.

